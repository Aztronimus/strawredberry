<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Grapher</title>
	<link rel="stylesheet" type="text/css" href="style.css">
	<script type="text/javascript" src="../load-mathjax.js"></script>
</head>
<body>
	<h1>Grapher</h1>
	<h2>Functions (R to R, parametric & polar)</h2>
	<div class="center">
		<canvas id="canvas1" width="800" height="600"></canvas>
		<form autocomplete="off"><div id="ctxMenu1" class="dialog">
			<div class="legend">canvas1 - 800px Ã— 600px</div>
			<div class="row">
				<div class="field">
					<div>X range from</div>
					<input type="text" name="" placeholder="value">
				</div>
				<div class="field">
					<div>X range to</div>
					<input type="text" name="" placeholder="value">
				</div>
				<div class="field">
					<div>Y range from</div>
					<input type="text" name="" placeholder="value">
				</div>
				<div class="field">
					<div>Y range to</div>
					<input type="text" name="" placeholder="value">
				</div>
			</div>
			<div class="row">
				<div class="field">
					<div>Number of points</div>
					<input type="text" name="" placeholder="Insert value">
				</div>
				<div class="field">
					<div>Type</div>
					<select>
						<option>Sharp</option>
						<option>Smooth</option>
						<option>Points</option>
					</select>
				</div>
			</div>
			<div class="row">
				<input name="back" class="back" type="button" name="" value="BACK">
				<input class="save" type="button" name="" value="SAVE">
			</div>
		</div></form>
	</div>
	<script type="text/javascript">
		// ------------------ Functions ----------------------------------
		let getAngle = (() => {
			let z = 0;
			const r = Math.PI / 2;
			return function([x, y]) {
				z = Math.atan(y / x);
				if(x > 0) {
					return z;
				} else if(x < 0) {
					if(y > 0) {
						return z + Math.PI;
					}
					else if(y < 0) {
						return z - Math.PI;
					}
					else {
						return Math.PI;
					}
				} else {
					if(y > 0) {
						return r;
					}
					else if(y < 0) {
						return -r
					}
					else {
						return NaN; 
					}
				}
			}
		})();

		function getDistance(a, b) {
			return Math.sqrt((a[1] - b[1])**2 + (a[0] - b[0])**2);
		}

		function getUnitVector([a, b], c = 1) {
			let n = Math.sqrt(a**2 + b**2);
			return [c * a / n, c * b / n];
		}

		function addVectors(u, v) {
			let r = [];
			for(let i in u) {
				r.push(u[i] + v[i]);
			}
			return r;
		}

		function subVectors(u, v) {
			let r = [];
			for(let i in u) {
				r.push(u[i] - v[i]);
			}
			return r;
		}

		function scalarProductVector(c, v) {
			let r = [];
			for(let x of v) {
				r.push(c * x);
			}
			return r;
		}

		function drawPolyline(p, ctx) {
			ctx.beginPath();
			p = [...p];
			ctx.moveTo(...p.shift());
			for(let i of p)
				ctx.lineTo(...i);
			ctx.stroke();
			ctx.closePath();
		}

		function drawPolycurveBezier(p, ctx) {
			ctx.beginPath();
			if((p.length - 1) % 3 != 0) {
				throw `Wrong number of points: ${p.length}`;
			}
			const _i = (p.length - 1) / 3;
			ctx.moveTo(...p[0]);
			for(let i = 0; i != _i; i++) {
				let j = 3 * i + 1;
				ctx.bezierCurveTo(...p[j], ...p[j + 1], ...p[j + 2]);
			}
			ctx.stroke();
			ctx.closePath();
		}

		function plineToPcurveBezier(p) {
			let c = getDistance(p[0], p[1]) / 4;
			let r = [p[0]];
			let w, u, v = getUnitVector(subVectors(p[1], p[0]));

			r.push(addVectors(scalarProductVector(c, v), p[0]));

			let i = 0, _i = p.length - 1;
			while(++i != _i) {
				u = v;
				v = getUnitVector(subVectors(p[i + 1], p[i]));
				w = getUnitVector(addVectors(v, u));
				r.push(addVectors(p[i], scalarProductVector(-c, w)));
				r.push(p[i]);
				c = getDistance(p[i], p[i + 1]) / 4;
				r.push(addVectors(p[i], scalarProductVector(c, w)));
			}

			r.push(addVectors(scalarProductVector(-c, v), p[_i]));
			r.push(p[_i])
			return r;
		}

		let drawArrow = (() => {
			let r = 15;
			let a = r * 1.5;
			let b = r * Math.sqrt(3) / 2;
			return function(p, ctx) {
				let v = [p[0][0] - p[1][0], p[0][1] - p[1][1]];
				let u = getUnitVector(v);
				ctx.beginPath();
				ctx.moveTo(...p[0]);
				ctx.lineTo(p[1][0] + r * u[0], p[1][1] + r * u[1]);
				ctx.stroke();
				ctx.closePath();
				ctx.translate(...p[1]);
				ctx.rotate(getAngle(v));
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(a, b);
				ctx.lineTo(a, -b);
				ctx.fill();
				ctx.closePath();
				ctx.setTransform(1, 0, 0, 1, 0, 0);
			}
		})();

		function drawCircle(p, ctx) {
			ctx.beginPath();
			ctx.arc(...p, 30, 0, 2*Math.PI);
			ctx.closePath();
			ctx.stroke();
		}

		function drawPoint(p, ctx) {
			ctx.beginPath();
			ctx.arc(...p, 5, 0, 2*Math.PI);
			ctx.closePath();
			ctx.fill();
		}

		function drawPoints(p, ctx) {
			for(let x of p) {
				ctx.beginPath();
				ctx.arc(...x, 5, 0, 2*Math.PI);
				ctx.closePath();
				ctx.fill();
			}
		}

		let p = [
			[100, 100],
			[200, 150],
			[300, 300],
			[400, 400],
			[500, 250],
			[600, 300],
			[700, 150]
		];
		// -------------------- Drawing ----------------------------------

		let canvas1 = document.getElementById("canvas1"),
		ctx1 = canvas1.getContext("2d");
		ctx1.strokeStyle = "white";
		ctx1.lineWidth = 10;
		ctx1.lineCap = "bevel";
		ctx1.lineJoin = "round";
		ctx1.fillStyle = "white";


		// drawPolyline(p, ctx1);
		// drawCircle(p[0], ctx1);

		// drawArrow([[200, 400], [600, 500]], ctx1);
		// drawArrow([p[1], addVectors(p[1], subVectors(p[2], p[0]))], ctx1);
		// drawArrow([p[1], addVectors(p[1], scalarProductVector(100, getUnitVector(subVectors(p[2], p[0]))))], ctx1);

		drawPolycurveBezier(plineToPcurveBezier(p), ctx1);
		// ctx1.fillStyle = "red";
		// drawPoints(p, ctx1);
		// drawPoints(plineToPcurveBezier(p), ctx1);
		// ctx1.fillStyle = "cyan";
		// drawPoints(p, ctx1);
		// ------------------- Document ----------------------------------

		const ctxMenu = document.getElementById("ctxMenu1");

		canvas1.addEventListener("contextmenu", function(e) {
			e.preventDefault();
			e.stopPropagation();
			ctxMenu.style.display = "block";
		});

		let form1 = document.querySelector("form"),
		backBtn = form1.elements.back;
		backBtn.addEventListener("click", function() {
			ctxMenu.style.display = "none";
		});
	</script>
</body>
</html>
<!-- 
	vector fields
	electromagnetic field
 -->
<!-- 
https://math.stackexchange.com/questions/2828057/what-is-the-equation-to-produce-this-bezier-curve

https://holycoders.com/javscript-copy-array/

https://www.w3resource.com/html5-canvas/html5-canvas-lines.php
https://www.w3schools.com/Tags/canvas_beziercurveto.asp

https://www.c-sharpcorner.com/UploadFile/99bb20/canvas-curves-in-html5/

https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
https://techglimpse.com/scale-rotate-transform-methods-canvas/

https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
 -->